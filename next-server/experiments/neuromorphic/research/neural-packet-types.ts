/**
 * Experimental: Neuromorphic Packet Routing
 * 
 * Bio-inspired packet networking where packets behave like neural signals,
 * using QoS as synaptic weights and BGP-style routing as Hebbian learning.
 * 
 * WARNING: This is highly experimental research code exploring the intersection
 * of neuroscience, networking, and AI. Not for production use!
 */

// ============================================================================
// NEURAL PACKET TYPES
// ============================================================================

/**
 * Packet types for neuromorphic experiments
 */
export enum PacketType {
  PERCEPTION = 'PERCEPTION',
  INFERENCE = 'INFERENCE',
}

/**
 * Differentiated Services Code Points mapped to cognitive priority levels
 */
export enum DSCP {
  // Neural priority classes (descending priority)
  CONSCIOUS_THOUGHT = 46,      // EF - Expedited Forwarding (highest)
  ATTENTION_FOCUS = 34,        // AF41 - Assured Forwarding Class 4
  WORKING_MEMORY = 26,         // AF31 - Assured Forwarding Class 3
  BACKGROUND_PROCESS = 18,     // AF21 - Assured Forwarding Class 2
  SUBCONSCIOUS = 10,          // AF11 - Assured Forwarding Class 1
  DEFAULT = 0                 // BE - Best Effort
}

/**
 * Quality of Service parameters with neural dynamics
 */

/**
 * Synaptic path metadata used by routing and attention
 */
export interface SynapticPath {
  source: string;
  destination: string;
  intermediates: string[];
  weight?: number;
  delay?: number;
  reliability?: number;
}

/**
 * Cognitive areas (simplified)
 */
export enum CognitiveAS {
  THALAMUS = 'THALAMUS',
  ACC = 'ACC',
  HIPPOCAMPUS = 'HIPPOCAMPUS',
  PREFRONTAL = 'PREFRONTAL',
}

/**
 * Minimal synaptic weight record for experiments
 */
export class SynapticWeight {
  strength = 1.0;
  lastUsed: bigint = BigInt(0);
  totalUses = 0;
  winStreak = 0;
  lossStreak = 0;
  qosClass: DSCP = DSCP.DEFAULT;
  bandwidth = 1.0;
  priority = 0;
  averageLatency = 0;
}

/**
 * Minimal multi-armed bandit arm stats
 */
export class ArmStats {
  pulls = 0;
  meanReward = 0;
  variance = 0;
  qosMultiplier = 1;
  lastPull: bigint = BigInt(0);
}
export interface NeuralQoS {
  // Standard QoS parameters
  dscp: DSCP;                // Differentiated Services Code Point
  latency: number;           // ms - propagation speed (inverse of neural conduction velocity)
  bandwidth: number;         // bps - channel capacity (synaptic strength)
  jitter: number;           // ms - timing variance (neural noise)
  loss: number;             // % - packet drop rate (synaptic failure rate)
  
  // Neural-specific QoS parameters
  spikeRate: number;        // Hz - firing frequency
  burstiness: number;       // 0-1 - temporal clustering (burst firing)
  coherence: number;        // 0-1 - phase alignment with other packets
  plasticityRate: number;   // 0-1 - how quickly this route adapts
}

/**
 * Neural packet extends base packet with brain-inspired properties
 */
export interface NeuralPacket {
  // Packet identification
  id: string;
  streamId: number;
  sequenceNumber: number;
  timestamp: bigint;
  
  // Neural properties
  amplitude: number;         // 0-1, signal strength (maps to priority)
  frequency: number;         // Hz, oscillation frequency
  phase: number;            // 0-2Ï€, for interference patterns
  harmonics: number[];      // Frequency multiples for binding
  
  // QoS parameters
  qos: NeuralQoS;
  
  // Payload
  payload: any;
  
  // Routing metadata
  path?: SynapticPath;
  hops?: number;
  ttl?: number;
}

/**
 * Interface for a token generated by the Moshi kernel
 */
export interface MoshiToken {
  value?: string;
  probability?: number;
  logits?: number[];
  attentionWeights?: number[];
}
/**
 * Interference pattern from multiple neural packets
 */
export interface InterferencePattern {
  intensity: number;         // Summed amplitude (constructive/destructive)
  binding: number;          // Gamma-band coherence (40Hz)
  frequency: number;        // Dominant frequency
  phase: number;           // Resultant phase
  locations: string[];     // Where interference is strongest
}

/**
 * Memory trace stored via harmonic resonance
 */
export interface MemoryTrace {
  content: any;            // Stored information
  strength: number;        // 0-1, memory strength
  frequency: number;       // Resonant frequency for retrieval
  phase: number;          // Phase encoding
  timestamp: bigint;      // When stored
  accessCount: number;    // How often accessed (LRU)
  decay: number;         // Forgetting rate
}

/**
 * A racing context for competitive thoughts
 */
export interface RaceResult {
  thought: NeuralPacket;
  raceTime: number;
  path: SynapticPath;
  hops: number;
  winner: boolean;
}

export class Race {
  id: string;
  startTime: number;
  participants: Map<string, RaceResult> = new Map();
  winner?: RaceResult;
  
  constructor(id: string) {
    this.id = id;
    this.startTime = (globalThis.performance?.now?.() ?? Date.now());
  }
}

/**
 * Types of ion channels for gating
 */
export enum IonChannel {
  SODIUM = 'Na+',           // Fast depolarization
  POTASSIUM = 'K+',         // Repolarization
  CALCIUM = 'Ca2+',         // Slow signals, plasticity
  CHLORIDE = 'Cl-',         // Inhibition
  NMDA = 'NMDA',           // Coincidence detection
  AMPA = 'AMPA',           // Fast excitation
  GABA = 'GABA',           // Fast inhibition
}

/**
 * Configuration for micro-expert gates
 */
export interface GateConfig {
  threshold: number;         // Activation threshold (mV equivalent)
  resonantFreq: number;     // Preferred frequency (Hz)
  ionChannel: IonChannel;   // Type of channel
  refractory: number;       // Refractory period (ms)
  adaptation: number;       // Spike-frequency adaptation rate
}

/**
 * Neural oscillation bands
 */
export enum OscillationBand {
  DELTA = 'delta',          // 0.5-4 Hz (deep sleep)
  THETA = 'theta',          // 4-8 Hz (memory, navigation)
  ALPHA = 'alpha',          // 8-12 Hz (relaxation, inhibition)
  BETA = 'beta',            // 12-30 Hz (active thinking)
  GAMMA = 'gamma',          // 30-100 Hz (binding, consciousness)
  HIGH_GAMMA = 'high_gamma' // 100-200 Hz (micro-consciousness)
}

/**
 * Get the frequency range for an oscillation band
 */
export function getOscillationRange(band: OscillationBand): [number, number] {
  switch (band) {
    case OscillationBand.DELTA: return [0.5, 4];
    case OscillationBand.THETA: return [4, 8];
    case OscillationBand.ALPHA: return [8, 12];
    case OscillationBand.BETA: return [12, 30];
    case OscillationBand.GAMMA: return [30, 100];
    case OscillationBand.HIGH_GAMMA: return [100, 200];
  }
}

/**
 * Calculate interference between two waves
 */
export function calculateInterference(
  wave1: { amplitude: number; frequency: number; phase: number },
  wave2: { amplitude: number; frequency: number; phase: number }
): number {
  // Simplified interference calculation
  const phaseDiff = wave2.phase - wave1.phase;
  const freqRatio = wave2.frequency / wave1.frequency;
  
  // Constructive if in phase and similar frequency
  if (Math.abs(phaseDiff) < Math.PI / 4 && Math.abs(freqRatio - 1) < 0.1) {
    return wave1.amplitude + wave2.amplitude;
  }
  
  // Destructive if out of phase
  if (Math.abs(phaseDiff - Math.PI) < Math.PI / 4) {
    return Math.abs(wave1.amplitude - wave2.amplitude);
  }
  
  // Partial interference
  return Math.sqrt(
    wave1.amplitude ** 2 + 
    wave2.amplitude ** 2 + 
    2 * wave1.amplitude * wave2.amplitude * Math.cos(phaseDiff)
  );
}

/**
 * Check if frequency is within an oscillation band
 */
export function isInBand(frequency: number, band: OscillationBand): boolean {
  const [min, max] = getOscillationRange(band);
  return frequency >= min && frequency <= max;
}

/**
 * Generate harmonics for a fundamental frequency
 */
export function generateHarmonics(fundamental: number, count: number = 5): number[] {
  const harmonics: number[] = [];
  for (let i = 1; i <= count; i++) {
    harmonics.push(fundamental * (i + 1)); // 2f, 3f, 4f, etc.
  }
  return harmonics;
}

/**
 * Calculate phase coherence between multiple packets
 */
export function calculateCoherence(packets: NeuralPacket[]): number {
  if (packets.length < 2) return 1.0;
  
  let sumCos = 0;
  let sumSin = 0;
  
  for (const packet of packets) {
    sumCos += Math.cos(packet.phase);
    sumSin += Math.sin(packet.phase);
  }
  
  const meanCos = sumCos / packets.length;
  const meanSin = sumSin / packets.length;
  
  // Phase locking value (PLV)
  return Math.sqrt(meanCos ** 2 + meanSin ** 2);
}